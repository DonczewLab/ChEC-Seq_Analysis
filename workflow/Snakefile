configfile: "config/config.yml"

##################################################################
##                    Define input functions                    ##
##################################################################

# Author: Kevin Boyd
# Date: March 27, 2025
# Adapted from: Chec-Seq Protocol from Rafal Donczew & John Ridenour

##################################################################
##                  Specific Steps in Pipeline                  ##
##################################################################

# Steps:
#  1) FastQC
#  2) Adapter Trim (BBDuk)
#  3) Align to S. cerevisiae (primary, no spike-in)
#  4) Align to D. melanogaster (spike-in)
#  5) Create Raw BigWig (from scer)
#  6) Calculate Spike-In Factors (all samples -> single CSV)
#  7) Create Spike-In Normalized BigWigs
#  8) Create CPM Normalized BigWigs
#  9) [Optional] Mean coverage BigWigs

##################################################################
##                    Define input functions                    ##
##################################################################

import os
import pandas as pd

# load samples table and set samples naming
samples_df = pd.read_csv(config["samples_csv"])
samples_df.set_index("sample", inplace=True, drop=False)
SAMPLES = samples_df.index.tolist()

# dictionary based input function
def fq_dict_from_sample(wildcards):
    """
    Return a dict: {"r1": <R1path>, "r2": <R2path>} for each sample.
    We'll use 'unpack(...)' in the rules so we can reference input.r1, input.r2.
    """
    row = samples_df.loc[wildcards.sample]
    return {
        "r1": row["fastq1"],
        "r2": row["fastq2"]
    }

##################################################################
##                          Rule All                            ##
##################################################################

rule all:
    input:
        # 1) FastQC
        expand("results/qc/fastqc/{sample}_R1_fastqc.html", sample=SAMPLES),
        expand("results/qc/fastqc/{sample}_R2_fastqc.html", sample=SAMPLES),

        # 2) Trimmed FASTQs
        expand("results/trimmed/{sample}_R1_trimmed.fastq.gz", sample=SAMPLES),
        expand("results/trimmed/{sample}_R2_trimmed.fastq.gz", sample=SAMPLES),

        # 3) scer BAM + BAI
        expand("results/alignment/scer/{sample}.bam", sample=SAMPLES),
        expand("results/alignment/scer/{sample}.bam.bai", sample=SAMPLES),

        # 4) dmel BAM + BAI
        expand("results/alignment/dmel/{sample}.bam", sample=SAMPLES),
        expand("results/alignment/dmel/{sample}.bam.bai", sample=SAMPLES),

        # 5) Raw BigWigs (scer)
        expand("results/bigwig/scer/raw/{sample}_raw.bw", sample=SAMPLES),

        # 6) single CSV with spike-in factors
        "results/spikein_factors/spikein_factors.csv",

        # 7) Spike-in normalized BigWigs (scer)
        expand("results/bigwig/scer/spikein/{sample}_SpikeIn.bw", sample=SAMPLES),

        # 8) CPM BigWigs (scer)
        expand("results/bigwig/scer/cpm/{sample}_CPM.bw", sample=SAMPLES),

        # 9) [Optional] mean coverage BigWigs (if merging replicates)
        # expand("results/bigwig/scer/cpm_mean/{sample}_CPM_mean.bw", sample=SAMPLES)


##################################################################
##                       Quality Control                        ##
##################################################################

rule fastqc_raw:
    input:
        unpack(fq_dict_from_sample)
    output:
        html1="results/qc/fastqc/{sample}_R1_fastqc.html",
        zip1 ="results/qc/fastqc/{sample}_R1_fastqc.zip",
        html2="results/qc/fastqc/{sample}_R2_fastqc.html",
        zip2 ="results/qc/fastqc/{sample}_R2_fastqc.zip"
    envmodules:
        config["fastqc"]
    log:
        "results/logs/fastqc/{sample}.log"
    shell:
        """
        fastqc -o results/qc/fastqc {input.r1} {input.r2} 2> {log}

        dir="results/qc/fastqc"
        baseR1=$(basename {input.r1} .fastq.gz)
        mv $dir/${{baseR1}}_fastqc.html {output.html1} || true
        mv $dir/${{baseR1}}_fastqc.zip {output.zip1} || true

        baseR2=$(basename {input.r2} .fastq.gz)
        mv $dir/${{baseR2}}_fastqc.html {output.html2} || true
        mv $dir/${{baseR2}}_fastqc.zip {output.zip2} || true
        """


##################################################################
##                      Adapter Trimming                        ##
##################################################################

rule trim_adapters:
    input:
        unpack(fq_dict_from_sample)
    output:
        r1_trim="results/trimmed/{sample}_R1_trimmed.fastq.gz",
        r2_trim="results/trimmed/{sample}_R2_trimmed.fastq.gz"
    params:
        bbmap_ref=config["bbmap_ref"]
    envmodules:
        config["bbmap"]
    log:
        "results/logs/trim/{sample}.log"
    shell:
        """
        bbduk.sh -Xmx1g \
          in1={input.r1} \
          in2={input.r2} \
          out1={output.r1_trim} \
          out2={output.r2_trim} \
          ref={params.bbmap_ref} \
          k=23 ktrim=r mink=11 hdist=1 tpe=t tbo=t \
          threads=8 2> {log}
        """


##################################################################
##               Align to S. cerevisiae (primary)               ##
##################################################################

rule align_scer:
    input:
        r1="results/trimmed/{sample}_R1_trimmed.fastq.gz",
        r2="results/trimmed/{sample}_R2_trimmed.fastq.gz"
    output:
        bam="results/alignment/scer/{sample}.bam",
        bai="results/alignment/scer/{sample}.bam.bai"
    params:
        bowtie2_idx=config["scer_genome"]
    envmodules:
        config["bowtie2"],
        config["samtools"]
    log:
        "results/logs/alignment/scer/{sample}.log"
    shell:
        """
        bowtie2 --very-sensitive-local --threads 16 \
            -x {params.bowtie2_idx} \
            -1 {input.r1} -2 {input.r2} \
            --maxins 700 --dovetail --no-unal --no-mixed --no-discordant \
            2> {log} | \
        samtools fixmate -O bam -@ 8 -m - - | \
        samtools sort -O bam -@ 8 -o {output.bam}
        samtools index -@ 8 {output.bam} {output.bai}
        """


##################################################################
##             Align to D. melanogaster (spike-in)              ##
##################################################################

rule align_dmel:
    input:
        r1="results/trimmed/{sample}_R1_trimmed.fastq.gz",
        r2="results/trimmed/{sample}_R2_trimmed.fastq.gz"
    output:
        bam="results/alignment/dmel/{sample}.bam",
        bai="results/alignment/dmel/{sample}.bam.bai"
    params:
        bowtie2_spikein=config["spikein_genome"]
    envmodules:
        config["bowtie2"],
        config["samtools"]
    log:
        "results/logs/alignment/dmel/{sample}.log"
    shell:
        """
        bowtie2 --very-sensitive-local --threads 16 \
            -x {params.bowtie2_spikein} \
            -1 {input.r1} -2 {input.r2} \
            --maxins 700 --dovetail --no-unal --no-mixed --no-discordant \
            2> {log} | \
        samtools fixmate -O bam -@ 8 -m - - | \
        samtools sort -O bam -@ 8 -o {output.bam}
        samtools index -@ 8 {output.bam} {output.bai}
        """


##################################################################
##                   BigWig Generation (raw)                    ##
##################################################################

rule make_bigwig_raw_scer:
    input:
        "results/alignment/scer/{sample}.bam"
    output:
        "results/bigwig/scer/raw/{sample}_raw.bw"
    params:
        binSize=config["binSize"],
        blacklist=config["blacklist_scer"]
    envmodules:
        config["deeptools"]
    log:
        "results/logs/bigwig/scer_raw/{sample}.log"
    shell:
        """
        bamCoverage --bam {input} \
            --outFileName {output} \
            --binSize {params.binSize} \
            --numberOfProcessors 4 \
            --normalizeUsing None \
            --blackListFileName {params.blacklist}
        """

################################################################################
# RULE: Calculate Spike-In Factors (single CSV)
################################################################################
rule calc_spikein_factors:
    """
    Gather ALL scer + dmel BAMs, pass them to scripts/calc_spikein.py,
    which writes results/spikein_factors/spikein_factors.csv.
    """
    input:
        scer_bams = expand("results/alignment/scer/{sample}.bam", sample=SAMPLES),
        dmel_bams = expand("results/alignment/dmel/{sample}.bam", sample=SAMPLES)
    output:
        "results/spikein_factors/spikein_factors.csv"
    envmodules:
        config["samtools"],
        config["python"]
    log:
        "results/logs/spikein/calc_spikein.log"
    shell:
        """
        python scripts/calc_spikein.py {output} {input.scer_bams} {input.dmel_bams} \
        2> {log}
        """


##################################################################
##                 BigWig Generation (spike-in)                 ##
##################################################################

rule make_bigwig_scer_spikein:
    """
    Use the factor from spikein_factors.csv to scale coverage in scer BAM,
    producing a spike-in normalized bigWig.
    """
    input:
        bam="results/alignment/scer/{sample}.bam",
        csv="results/spikein_factors/spikein_factors.csv"
    output:
        "results/bigwig/scer/spikein/{sample}_SpikeIn.bw"
    params:
        binSize=config["binSize"],
        blacklist=config["blacklist_scer"]
    envmodules:
        config["deeptools"],
        config["python"]
    log:
        "results/logs/bigwig/spikein/{sample}.log"
    shell:
        r"""
        # 1) Extract the factor for this sample from CSV
        factor=$(python <<EOF
import csv
sample_name = "{wildcards.sample}"
factor = 1.0
with open("{input.csv}", "r") as inf:
    reader = csv.DictReader(inf)
    for row in reader:
        if row["sample"] == sample_name:
            factor = float(row["spikein_factor"])
            break
print(factor)
EOF
)

        echo "Spike-in factor for {wildcards.sample} = $factor" >> {log}

        # 2) Run bamCoverage with that scale factor
        bamCoverage --bam {input.bam} \
                    --outFileName {output} \
                    --binSize {params.binSize} \
                    --numberOfProcessors 4 \
                    --scaleFactor $factor \
                    --blackListFileName {params.blacklist}
        """

##################################################################
##                   BigWig Generation (cpm)                    ##
##################################################################

rule make_bigwig_scer_cpm:
    """
    Generate CPM-normalized bigWig from scer BAM.
    """
    input:
        "results/alignment/scer/{sample}.bam"
    output:
        "results/bigwig/scer/cpm/{sample}_CPM.bw"
    params:
        binSize=config["binSize"],
        blacklist=config["blacklist_scer"]
    envmodules:
        config["deeptools"]
    log:
        "results/logs/bigwig/scer_cpm/{sample}.log"
    shell:
        """
        bamCoverage --bam {input} \
            --outFileName {output} \
            --binSize {params.binSize} \
            --numberOfProcessors 4 \
            --normalizeUsing CPM \
            --blackListFileName {params.blacklist}
        """


################################################################################
# OPTIONAL: Mean Coverage BigWigs (if you have replicates)
################################################################################
rule make_bedgraph_scer_cpm:
    """
    Make a CPM bedGraph from scer BAM. Then you can merge replicate bedGraphs.
    """
    input:
        "results/alignment/scer/{sample}.bam"
    output:
        "results/bedgraph/scer/cpm/{sample}.bg"
    params:
        binSize=config["binSize"],
        blacklist=config["blacklist_scer"]
    envmodules:
        config["deeptools"]
    log:
        "results/logs/bedgraph/scer_cpm/{sample}.log"
    shell:
        """
        bamCoverage --bam {input} \
            --outFileName {output} \
            --outFileFormat bedgraph \
            --binSize {params.binSize} \
            --numberOfProcessors 4 \
            --normalizeUsing CPM \
            --blackListFileName {params.blacklist}
        """

rule merge_bedgraphs_mean_cpm:
    """
    Union multiple replicate bedGraphs for a sample, compute mean coverage.
    Adjust 'rep' to your replicate labels.
    """
    input:
        expand("results/bedgraph/scer/cpm/{{sample}}_{rep}.bg", rep=["1","2","3"])
    output:
        "results/bedgraph/scer/cpm_mean/{sample}.bg"
    envmodules:
        config["bedtools"]
    log:
        "results/logs/bedgraph/merge_{sample}.log"
    shell:
        r"""
        bedtools unionbedg -i {input} | \
        awk 'OFS="\t" {
          sum=0; 
          for (i=4; i<=NF; i++) sum+=$i;
          print $1,$2,$3,sum/(NF-3)
        }' | sort -k1,1 -k2,2n > {output}
        """

rule bedgraph_to_bigwig_mean_cpm:
    """
    Convert the mean-coverage bedGraph to BigWig.
    """
    input:
        "results/bedgraph/scer/cpm_mean/{sample}.bg"
    output:
        "results/bigwig/scer/cpm_mean/{sample}_CPM_mean.bw"
    params:
        genome_file=config["genome_file_scer"]
    envmodules:
        config["ucsc"]
    log:
        "results/logs/bedgraph/bw_mean_{sample}.log"
    shell:
        """
        bedGraphToBigWig {input} {params.genome_file} {output} 2> {log}
        """

