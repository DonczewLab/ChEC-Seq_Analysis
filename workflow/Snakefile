configfile: "config/config.yml"

##################################################################
##                    Define input functions                    ##
##################################################################

# Author: Kevin Boyd
# Date: March 27, 2025
# Adapted from: Chec-Seq Protocol from Rafal Donczew & John Ridenour

##################################################################
##                  Specific Steps in Pipeline                  ##
##################################################################

# Steps:
#  1) FastQC
#  2) Adapter Trim (BBDuk)
#  3) Align to S. cerevisiae (primary, no spike-in)
#  4) Align to D. melanogaster (spike-in)
#  5) Create Raw BigWig (from scer)
#  6) Calculate Spike-In Factors (all samples -> single CSV)
#  7) Create Spike-In Normalized BigWigs
#  8) Create CPM Normalized BigWigs
#  9) [Optional] Mean coverage BigWigs

##################################################################
##                    Define input functions                    ##
##################################################################

import os
import pandas as pd

# load samples table and set samples naming
samples_df = pd.read_csv("config/samples.csv").set_index("sample", drop=False)
SAMPLES = samples_df.index.tolist()

# dictionary based input function
def fq_dict_from_sample(wildcards):
    """
    Return a dict: {"r1": <R1path>, "r2": <R2path>} for each sample.
    Use 'unpack(...)' in the rules so we can reference input.r1, input.r2.
    """
    row = samples_df.loc[wildcards.sample]
    return {
        "r1": row["fastq1"],
        "r2": row["fastq2"]
    }

# Extract unique merge groups from the new column (e.g. DMSO, IAA, etc.)
merge_groups = samples_df["merge_group"].unique().tolist()

def bedgraphs_for_group(wildcards):
    """
    Return a list of bedGraph files belonging to 'merge_group' == wildcards.group.
    E.g., if group='DMSO', collect all samples with merge_group='DMSO',
    returning ['results/bedgraph/cpm/RDY226_DMSO_A_cpm.bg', ...].
    """
    # Filter samples by group
    samples_in_group = [
        s for s in SAMPLES
        if samples_df.loc[s, "merge_group"] == wildcards.group
    ]
    # Build the bedGraph filenames for those samples
    return [
        f"results/bedgraph/cpm/{sample}_cpm.bg"
        for sample in samples_in_group
    ]

##################################################################
##                          Rule All                            ##
##################################################################

rule all:
    input:
        # 1) FastQC
        expand("results/qc/fastqc/{sample}_R1_fastqc.html", sample=SAMPLES),
        expand("results/qc/fastqc/{sample}_R2_fastqc.html", sample=SAMPLES),

        # 2) Trimmed FASTQs
        expand("results/trimmed/{sample}_R1_trimmed.fastq.gz", sample=SAMPLES),
        expand("results/trimmed/{sample}_R2_trimmed.fastq.gz", sample=SAMPLES),

        # 3) scer BAM + BAI
        expand("results/alignment/scer/{sample}.bam", sample=SAMPLES),
        expand("results/alignment/scer/{sample}.bam.bai", sample=SAMPLES),

        # 4) Spike-In (dmel) BAM + BAI
        expand("results/alignment/spikein/{sample}.bam", sample=SAMPLES),
        expand("results/alignment/spikein/{sample}.bam.bai", sample=SAMPLES),

        # 5) Raw BigWigs
        expand("results/bigwig/raw/{sample}_raw.bw", sample=SAMPLES),

        # 6) single CSV with spike-in factors
        "results/spikein_factors/spikein_factors.csv",

        # 7) Spike-in normalized BigWigs
        expand("results/bigwig/spikein/{sample}_SpikeIn.bw", sample=SAMPLES),

        # 8) CPM BigWigs
        expand("results/bigwig/cpm/{sample}_cpm.bw", sample=SAMPLES),

        # 9) CPM BegGraphs
        expand("results/bedgraph/cpm/{sample}_cpm.bg", sample=SAMPLES),

        # 10) Mean coverage BedGraphs
        expand("results/bedgraph/cpm_mean/{group}_cpm_mean.bg", group=merge_groups),

        # 11) Mean coverage BigWigs
        expand("results/bigwig/cpm_mean/{group}_cpm_mean.bw", group=merge_groups)


##################################################################
##                       Quality Control                        ##
##################################################################

rule fastqc_raw:
    input:
        unpack(fq_dict_from_sample)
    output:
        html1="results/qc/fastqc/{sample}_R1_fastqc.html",
        zip1 ="results/qc/fastqc/{sample}_R1_fastqc.zip",
        html2="results/qc/fastqc/{sample}_R2_fastqc.html",
        zip2 ="results/qc/fastqc/{sample}_R2_fastqc.zip"
    envmodules:
        config["fastqc"]
    log:
        "results/logs/fastqc/{sample}.log"
    shell:
        """
        fastqc -o results/qc/fastqc {input.r1} {input.r2} 2> {log}

        dir="results/qc/fastqc"
        baseR1=$(basename {input.r1} .fastq.gz)
        mv $dir/${{baseR1}}_fastqc.html {output.html1} || true
        mv $dir/${{baseR1}}_fastqc.zip {output.zip1} || true

        baseR2=$(basename {input.r2} .fastq.gz)
        mv $dir/${{baseR2}}_fastqc.html {output.html2} || true
        mv $dir/${{baseR2}}_fastqc.zip {output.zip2} || true
        """


##################################################################
##                      Adapter Trimming                        ##
##################################################################

rule trim_adapters:
    input:
        unpack(fq_dict_from_sample)
    output:
        r1_trim="results/trimmed/{sample}_R1_trimmed.fastq.gz",
        r2_trim="results/trimmed/{sample}_R2_trimmed.fastq.gz"
    params:
        bbmap_ref=config["bbmap_ref"]
    envmodules:
        config["bbmap"]
    log:
        "results/logs/trim/{sample}.log"
    shell:
        """
        bbduk.sh -Xmx1g \
          in1={input.r1} \
          in2={input.r2} \
          out1={output.r1_trim} \
          out2={output.r2_trim} \
          ref={params.bbmap_ref} \
          k=23 ktrim=r mink=11 hdist=1 tpe=t tbo=t \
          threads=8 2> {log}
        """


##################################################################
##               Align to S. cerevisiae (primary)               ##
##################################################################

rule align_scer:
    input:
        r1="results/trimmed/{sample}_R1_trimmed.fastq.gz",
        r2="results/trimmed/{sample}_R2_trimmed.fastq.gz"
    output:
        bam="results/alignment/scer/{sample}.bam",
        bai="results/alignment/scer/{sample}.bam.bai"
    params:
        bowtie2_scer=config["scer_genome"]
    envmodules:
        config["bowtie2"],
        config["samtools"]
    log:
        "results/logs/alignment/scer/{sample}.log"
    shell:
        """
        bowtie2 --very-sensitive-local --threads 16 \
            -x {params.bowtie2_scer} \
            -1 {input.r1} -2 {input.r2} \
            --maxins 700 --dovetail --no-unal --no-mixed --no-discordant \
            2> {log} | \
        samtools fixmate -O bam -@ 8 -m - - | \
        samtools sort -O bam -@ 8 -o {output.bam}
        samtools index -@ 8 {output.bam} {output.bai}
        """


##################################################################
##             Align to D. melanogaster (spike-in)              ##
##################################################################

rule align_spikein:
    input:
        r1="results/trimmed/{sample}_R1_trimmed.fastq.gz",
        r2="results/trimmed/{sample}_R2_trimmed.fastq.gz"
    output:
        bam="results/alignment/spikein/{sample}.bam",
        bai="results/alignment/spikein/{sample}.bam.bai"
    params:
        bowtie2_spikein=config["spikein_genome"]
    envmodules:
        config["bowtie2"],
        config["samtools"]
    log:
        "results/logs/alignment/spikein/{sample}.log"
    shell:
        """
        bowtie2 --very-sensitive-local --threads 16 \
            -x {params.bowtie2_spikein} \
            -1 {input.r1} -2 {input.r2} \
            --maxins 700 --dovetail --no-unal --no-mixed --no-discordant \
            2> {log} | \
        samtools fixmate -O bam -@ 8 -m - - | \
        samtools sort -O bam -@ 8 -o {output.bam}
        samtools index -@ 8 {output.bam} {output.bai}
        """


##################################################################
##                   BigWig Generation (raw)                    ##
##################################################################

rule make_bigwig_raw_scer:
    input:
        "results/alignment/scer/{sample}.bam"
    output:
        "results/bigwig/raw/{sample}_raw.bw"
    params:
        binSize=config["binSize"],
        blacklist=config["blacklist_scer"]
    envmodules:
        config["deeptools"]
    log:
        "results/logs/bigwig/scer_raw/{sample}.log"
    shell:
        """
        bamCoverage --bam {input} \
            --outFileName {output} \
            --binSize {params.binSize} \
            --numberOfProcessors 4 \
            --normalizeUsing None \
            --blackListFileName {params.blacklist}
        """


##################################################################
##                  Calculate Spike-In Factors                  ##
##################################################################

rule calc_spikein_factors:
    """
    Gather ALL scer + spikein BAMs, pass them to scripts/calc_spikein.py,
    which writes results/spikein_factors/spikein_factors.csv.
    """
    input:
        scer_bams = expand("results/alignment/scer/{sample}.bam", sample=SAMPLES),
        spikein_bams = expand("results/alignment/spikein/{sample}.bam", sample=SAMPLES)
    output:
        "results/spikein_factors/spikein_factors.csv"
    envmodules:
        config["samtools"],
        config["python"]
    log:
        "results/logs/spikein/calc_spikein.log"
    shell:
        """
        python scripts/calc_spikein.py {output} {input.scer_bams} {input.spikein_bams} \
        2> {log}
        """


##################################################################
##                 BigWig Generation (spike-in)                 ##
##################################################################

rule make_bigwig_scer_spikein:
    """
    Use the factor from spikein_factors.csv to scale coverage in scer BAM,
    producing a spike-in normalized bigWig.
    """
    input:
        bam="results/alignment/scer/{sample}.bam",
        csv="results/spikein_factors/spikein_factors.csv"
    output:
        "results/bigwig/spikein/{sample}_SpikeIn.bw"
    params:
        binSize=config["binSize"],
        blacklist=config["blacklist_scer"]
    envmodules:
        config["deeptools"],
        config["python"]
    log:
        "results/logs/bigwig/spikein/{sample}.log"
    shell:
        r"""
        # 1) Extract the factor for this sample from CSV
        factor=$(python <<EOF
import csv
sample_name = "{wildcards.sample}"
factor = 1.0
with open("{input.csv}", "r") as inf:
    reader = csv.DictReader(inf)
    for row in reader:
        if row["sample"] == sample_name:
            factor = float(row["spikein_factor"])
            break
print(factor)
EOF
)

        echo "Spike-in factor for {wildcards.sample} = $factor" >> {log}

        # 2) Run bamCoverage with that scale factor
        bamCoverage --bam {input.bam} \
                    --outFileName {output} \
                    --binSize {params.binSize} \
                    --numberOfProcessors 4 \
                    --scaleFactor $factor \
                    --blackListFileName {params.blacklist}
        """

##################################################################
##                   BigWig Generation (cpm)                    ##
##################################################################

rule make_bigwig_scer_cpm:
    """
    Generate CPM-normalized bigWig from scer BAM.
    """
    input:
        "results/alignment/scer/{sample}.bam"
    output:
        "results/bigwig/cpm/{sample}_cpm.bw"
    params:
        binSize=config["binSize"],
        blacklist=config["blacklist_scer"]
    envmodules:
        config["deeptools"]
    log:
        "results/logs/bigwig/scer_cpm/{sample}.log"
    shell:
        """
        bamCoverage --bam {input} \
            --outFileName {output} \
            --binSize {params.binSize} \
            --numberOfProcessors 4 \
            --normalizeUsing CPM \
            --blackListFileName {params.blacklist}
        """


##################################################################
##                   Generate BedGraphs (CPM)                   ##
##################################################################

rule make_bedgraph_scer_cpm:
    input:
        "results/alignment/scer/{sample}.bam"
    output:
        "results/bedgraph/cpm/{sample}_cpm.bg"
    params:
        binSize=config["binSize"],
        blacklist=config["blacklist_scer"]
    envmodules:
        config["deeptools"]
    log:
        "results/logs/bedgraph/{sample}_cpm.log"
    shell:
        """
        bamCoverage \
          --bam {input} \
          --outFileName {output} \
          --outFileFormat bedgraph \
          --binSize {params.binSize} \
          --numberOfProcessors 4 \
          --normalizeUsing CPM \
          --blackListFileName {params.blacklist} \
          2> {log}
        """


##################################################################
##                  Merge Bedgraphs (Mean CPM)                  ##
##################################################################

rule merge_bedgraphs_mean_cpm:
    """
    Combine all bedGraphs for a given merge_group (e.g., DMSO, IAA) into one.
    Then average coverage across the replicate bedGraphs, using bedtools unionbedg.
    """
    input:
        bedgraphs_for_group
    output:
        "results/bedgraph/cpm_mean/{group}_cpm_mean.bg"
    envmodules:
        config["bedtools"]
    log:
        "results/logs/bedgraph/merge_{group}.log"
    shell:
        r"""
        bedtools unionbedg -i {input} | \
        awk 'OFS="\t" {{
          sum=0; for (col=4; col<=NF; col++) sum += $col;
          print $1,$2,$3,sum/(NF-3);
        }}' | sort -k1,1 -k2,2n > {output}
        """


##################################################################
##               Mean Coverage BedGraph to BigWig               ##
##################################################################

rule bedgraph_to_bigwig_mean_cpm:
    input:
        "results/bedgraph/cpm_mean/{group}.bg"
    output:
        "results/bigwig/cpm_mean/{group}_cpm_mean.bw"
    params:
        genome_file=config["genome_file_scer"]
    envmodules:
        config["ucsc"]
    log:
        "results/logs/bedgraph/bw_mean_{group}.log"
    shell:
        """
        bedGraphToBigWig {input} {params.genome_file} {output} 2> {log}
        """
